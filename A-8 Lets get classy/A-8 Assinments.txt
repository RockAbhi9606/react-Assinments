
1. How Do You Create Nested Routes with react-router-dom?
Nested routes allow you to define routes within routes. Here's an example using react-router-dom:

import { BrowserRouter as Router, Route, Routes, Link, Outlet } from 'react-router-dom';

const Home = () => <h2>Home</h2>;
const About = () => <h2>About</h2>;
const Contact = () => <h2>Contact</h2>;

const Dashboard = () => (
  <div>
    <h2>Dashboard</h2>
    <nav>
      <Link to="profile">Profile</Link> | <Link to="settings">Settings</Link>
    </nav>
    <Outlet />
  </div>
);

const Profile = () => <h3>Profile</h3>;
const Settings = () => <h3>Settings</h3>;

const App = () => (
  <Router>
    <nav>
      <Link to="/">Home</Link> | <Link to="about">About</Link> | <Link to="dashboard">Dashboard</Link>
    </nav>
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="about" element={<About />} />
      <Route path="dashboard" element={<Dashboard />}>
        <Route path="profile" element={<Profile />} />
        <Route path="settings" element={<Settings />} />
      </Route>
    </Routes>
  </Router>
);


export default App;

============================================================
2. Read About createHashRouter and createMemoryRouter
createHashRouter: It is used to create a router that uses the hash portion of the URL (the part after #) to keep track of the current location. This is useful for applications where you cannot modify the server settings to support traditional URL routing.

createMemoryRouter: It creates a router that keeps the history of your "locations" in memory (doesn't read or write to the address bar). This is useful for testing or non-browser environments like React Native.

============================================================

3. Order of Life Cycle Method Calls in Class-Based Components
constructor
static getDerivedStateFromProps
render
componentDidMount
shouldComponentUpdate
static getDerivedStateFromProps
render
getSnapshotBeforeUpdate
componentDidUpdate
componentWillUnmount

============================================================


4. Why Do We Use componentDidMount?
componentDidMount is used to perform side effects after the component has been rendered to the DOM. Common uses include fetching data from an API, setting up subscriptions, or initializing third-party libraries.

Example:

class App extends React.Component {
  componentDidMount() {
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => this.setState({ data }));
  }

  render() {
    // Render component based on this.state.data
  }
}

================================================================

5. Why Do We Use componentWillUnmount? Show with Example
componentWillUnmount is used to clean up side effects when a component is about to be removed from the DOM. This can include clearing timers, cancelling network requests, or unsubscribing from subscriptions.

Example:

class App extends React.Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    console.log('Ticking...');
  }

  render() {
    return <div>Check console for ticking...</div>;
  }
}
===========================================================

6. Why Do We Use super(props) in Constructor?
When extending a class in JavaScript, you use super to call the constructor of the parent class. This is necessary to properly initialize the this context. If you need to access this.props in the constructor, you must pass props to super.

Example:

class Parent {
  constructor(props) {
    this.name = props.name;
  }
}

class Child extends Parent {
  constructor(props) {
    super(props); // Calls the parent class's constructor with the props
    console.log(this.name); // Now this.name is available
  }
}

===================================================================


7. Why Can't We Have the Callback Function of useEffect Async?
The callback function of useEffect should not be async because useEffect expects a cleanup function or nothing to be returned. An async function returns a Promise, which is not a valid return value for useEffect. Instead, you can define an async function inside the useEffect and call it.

Example:

import React, { useEffect } from 'react';

const App = () => {
  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch('https://api.example.com/data');
      const data = await response.json();
      console.log(data);
    };

    fetchData();
  }, []);

  return <div>Check console for data...</div>;
};

export default App;

By using these approaches, you can effectively manage your React component lifecycle and handle routing efficiently.






